# 프로젝트 가이드라인

이 문서는 LLM이 프로젝트의 맥락을 정확히 이해하고, 더 효율적이며 프로젝트에 특화된 도움을 제공하도록 돕기 위해 작성되었습니다.

## 프로젝트 개요 및 목표

* 프로젝트 이름: ZeroDi 개인 웹사이트
* 목표: 인디 개발자 'ZeroDi'의 개발 여정, 철학, 완성된 프로젝트를 효과적으로 공유하고, 비슷한 관심사를 가진 이들에게 영감을 주며, 잠재적 동료 및 팬들과 연결되는 것을 목표로 합니다. 비즈니스 의뢰 목적보다는 개인적인 브랜딩과 소통에 집중합니다.
* 주요 기능 (MVP): 이 프로젝트가 제공하는 핵심 기능들을 나열합니다. 각 기능에 해당하는 사용자 스토리 ID를 함께 명시하면 LLM이 특정 기능 개발 시 맥락을 이해하는 데 도움이 됩니다.
  * [US-001] "About Me" 섹션: 개발자 ZeroDi의 진솔한 개발 여정 스토리, 철학, 가치관을 담은 자기소개 페이지를 제공합니다.
  * [US-002] "Projects" 쇼케이스: ZeroDi가 만든 프로젝트들을 고품질 스크린샷, 데모 영상(링크), 기술 스택 아이콘, 간결한 설명과 함께 시각적으로 전시합니다.
  * [US-003] "Blog" (Indie Dev Log): ZeroDi의 개발 과정의 시행착오, 실험, 개인적인 생각, 영감 등을 자유롭게 기록하는 블로그 기능을 제공합니다.
  * [US-004] "Contact & Connect" 페이지: 이메일, 선호하는 SNS 링크, Ko-fi 후원 링크를 명확하고 친근하게 제시하여 방문자와의 소통을 유도합니다.
  * [US-005] 글로벌 내비게이션 바: Home, About, Projects, Blog, Contact 등 핵심 페이지로의 쉬운 이동을 위한 왼쪽 고정 내비게이션 바를 제공합니다.
  * [US-006] 반응형 디자인: 어떤 기기(모바일, 태블릿, 데스크톱)에서 접속해도 웹사이트가 최적화된 형태로 보기 좋게 표시됩니다.
  * [US-007] 최소한의 SEO 설정: 검색 엔진에서 기본적인 노출을 확보하기 위한 메타 태그, 제목 등 기본 SEO 요소를 설정합니다.
* 프로젝트 깃헙 레포지토리: `https://github.com/0disoft/0disoft.github.io`

## 기술 스택 및 환경

* 프론트엔드: Astro
  * 스타일링: UnoCSS
  * UI/UX 특징 (선택 사항): 깔끔하지만 따뜻한 '핸드메이드' 감성 디자인, 미니멀 & 모던 스타일 지향.
* 백엔드: 필요 없음
* 런타임: Bun
* 데이터베이스/BaaS: 필요 없음 (Astro Content Collections 활용)
* 배포 환경:
  * 프론트엔드 배포: GitHub Pages
  * 백엔드 배포: 해당 없음
* 의존성 관리: Bun을 패키지 매니저로 사용하며, 정기적인 의존성 업데이트 및 취약점 검토를 수행합니다.
* 지역화 (l10n, 선택 사항):
  * 다국어 페이지 지원 여부: 지원함 (MVP 이후 고려)
  * 기본 언어: 영어 (접속 국가 언어로 자동 선택 지원은 MVP 이후 고려)
  * 번역 파일 관리 방식: 수동 준비 (LLM을 이용한 직접 번역 포함)
* 개발 환경:
  * OS: **Windows 11**
  * IDE: **VS Code**
  * 터미널: **Git Bash**
  * 권장 확장 프로그램: VS Code with Astro, UnoCSS, Prettier, ESLint

## 코딩 규칙 및 스타일

* 변수/함수명: 명확하고 의미를 쉽게 유추할 수 있는 이름을 사용합니다. (예: `getData` 대신 `fetchUserProfileData`)
* 코드 라인 길이: 한 줄의 최대 길이는 80자 (띄어쓰기 포함)를 지킵니다. (예외: 긴 URL, 코드 블록, 테이블, 제목)
* 함수 길이: 함수의 최대 길이는 50라인 (주석 및 줄바꿈 포함)을 지킵니다.
* 들여쓰기: 특별한 경우가 아니라면 2칸 공백을 사용합니다.
* 커밋 메시지: Gitmoji 형식을 사용한 영어 코멘트를 작성합니다.
* Single Source of Truth: 서비스 이름, API 엔드포인트, 주요 설정 값 등은 코드 곳곳에 하드코딩하지 않습니다. 모든 설정은 별도의 설정 파일이나 상수 모듈에 모아서, 딱 한 군데만 수정하면 전체에 적용되도록 만듭니다.
* 모듈성: 코드를 작고 응집도 높은 모듈로 분리하여 재사용성과 유지보수성을 높입니다.
* 가독성: 다른 개발자가 코드를 쉽게 이해할 수 있도록 작성합니다.
* 성능: 특히 고빈도 호출이 예상되는 API나 데이터 처리 로직에서는 성능을 최우선으로 고려합니다.
* 보안: 사용자 데이터 보호, 인증/인가, 입력 유효성 검사 등 보안을 항상 염두에 둡니다. (프로젝트 특성에 따른 추가 보안 고려사항 명시 가능: 예: XSS/CSRF 방지, SQL Injection 방지, 비밀번호 해싱)
* 데이터 정확성: 제공되는 데이터(특히 계산 결과)는 최신 법규와 공식 데이터를 기반으로 최대한의 정확성을 보장해야 합니다. 부동 소수점 오류 방지를 위한 정밀한 숫자 연산 라이브러리 사용을 권장합니다.
* 에러 처리: 모든 잠재적인 에러 상황에 대해 견고하고 명확한 에러 처리 로직을 구현합니다. (예: 서버 측 폼 액션에서 `fail` 함수를 사용하여 개발자에게 구체적인 오류 메시지 전달)
* 접근성 (A11y): 웹 애플리케이션 개발 시 웹 접근성 표준을 준수하여 모든 사용자가 쉽게 접근하고 이용할 수 있도록 합니다. (처음부터 강력한 접근성 보장)
* 주석 작성 규칙: 주석은 '왜' 이 코드가 존재하는지, 코드를 변경했다면 '왜' 변경했는지, 특정 비즈니스 논리나 기술적 절충안 등 코드만으로 설명하기 어려운 배경 정보를 제공하는데 사용합니다.
* 마크다운 작성 규칙: 다음은 자주 발생하는 마크다운 오류이므로 항상 유의하여 작성합니다.
  * `MD030/list-marker-space`: 리스트 마커 다음에는 정확히 한 칸의 공백을 사용합니다.
  * `MD022/blanks-around-headings`: 제목(Heading)의 위와 아래에는 항상 한 줄씩 비워둡니다.
  * `MD047/single-trailing-newline`: 파일의 마지막은 항상 하나의 개행 문자로 끝나야 합니다.
  * `MD024/no-duplicate-heading`: 한 문서 내에서 동일한 내용의 제목을 중복으로 사용하지 않습니다.
  * `MD007/ul-indent`: 중첩되지 않은 리스트는 2칸 들여쓰기를 사용합니다.

## AI 지식 베이스 및 문서화

LLM의 학습 데이터 한계(Knowledge Cutoff)를 극복하고, 프로젝트의 기술적 맥락과 최신 정보를 정확하게 파악하기 위해 이 중앙화된 지식 베이스를 관리합니다. 코드를 분석하거나 생성할 때, 항상 이 내부 지식 베이스의 문서를 가장 먼저 확인하십시오.

* **위치**: LLM과 관련된 모든 문서는 `/.gemini/` 폴더 아래에 중앙화하여 관리합니다.

### 1. 프레임워크 최신 정보 (`/.gemini/.changelogs/` 및 `/.gemini/.context7/`)

* **목적**: LLM의 지식 격차를 해소하고, 최신 프레임워크 정보를 효과적으로 활용하기 위해 두 가지 유형의 문서를 관리합니다.
  * `/.gemini/.changelogs/`: 주요 프레임워크의 분기별(예: 25년 1분기, 2분기) 최신 업데이트 중, 반드시 알아야 할 핵심 변경 사항이나 주요 기능 추가 내용을 요약하여 저장합니다.
  * `/.gemini/.context7/`: `Context7` MCP를 통해 방대한 공식 문서를 검색하기 전, 로컬에서 자주 사용하는 기능의 일반적인 사용법이나 코드 스니펫을 빠르게 확인하기 위한 용도로 사용됩니다.
* **LLM 활용 가이드**:
  * 프레임워크의 최신 버전과 관련된 작업을 수행할 때는 먼저 `/.gemini/.changelogs/` 폴더를 확인하여 중요한 변경 사항(breaking changes 등)을 코드에 반영하십시오.
  * 특정 기능의 기본적인 사용법이나 예제가 필요할 때는 `/.gemini/.context7/` 폴더의 문서를 우선적으로 참조하여 빠르게 정보를 얻고, 더 상세한 내용이 필요할 경우에 `Context7` MCP를 활용하십시오.

### 2. 아키텍처 결정 기록 (`/.gemini/adr/`)

* **목적**: "왜(Why)" 특정 기술 스택이나 설계 패턴을 선택했는지 등, 프로젝트의 중요한 기술적 결정에 대한 이유와 배경을 기록합니다.
* **내용**: `001-monorepo-structure-decision.md` 와 같이 번호가 매겨진 마크다운 파일로 관리됩니다.
* **LLM 활용 가이드**: 새 ADR 작성 시 `_template.md` 파일을 복사하여 형식을 유지하십시오. 코드 제안 시에는 이 문서에 기록된 제약 조건과 역사적 맥락을 반드시 고려하십시오.

### 3. API 명세 (`/.gemini/api/`)

* **목적**: 주요 API 엔드포인트의 요청/응답 형식, 파라미터, 인증 요구사항, 반환 에러 코드 등을 명확하게 정의합니다.
* **내용**: `authentication.md`, `products.md` 와 같이 기능별로 파일이 분리되어 있습니다.
* **LLM 활용 가이드**: 새 API 문서 작성 시 `_template.md` 파일을 복사하여 구조를 유지하십시오. API 호출 또는 신규 엔드포인트 구현 시, 이 명세를 기준으로 정확한 코드를 생성하십시오.

### 4. 데이터 흐름 (`/.gemini/data-flow/`)

* **목적**: 사용자의 특정 행동이 시스템 전체(프론트엔드, 백엔드, 데이터베이스)에서 어떻게 처리되는지 그 과정을 기록합니다.
* **내용**: `checkout-process.md` 와 같이 핵심 사용자 시나리오별로 파일이 정리되어 있습니다.
* **LLM 활용 가이드**: 새 흐름도 작성 시 `_template.md` 파일을 참고하십시오. 풀스택 기능 개발 및 디버깅 시, 이 흐름도를 바탕으로 시스템 간 상호작용을 파악하고 코드를 작성하십시오.

### 5. 테스트 전략 (`/.gemini/testing/`)

* **목적**: 프로젝트의 테스트 철학, 종류별 테스트 작성법, 모킹(mocking) 가이드라인 등을 정의하여 코드 품질과 일관성을 확보합니다.
* **내용**: 테스트 전략, 종류별 가이드, 모킹 방법 등이 기술됩니다.
* **LLM 활용 가이드**: 새 테스트 가이드 작성 시 `_template.md` 파일을 참고하십시오. 새로운 기능을 개발할 때, 이 가이드라인에 따라 적절한 테스트 코드를 함께 생성하십시오.

### 6. 배포 가이드 (`/.gemini/deployment/`)

* **목적**: CI/CD 파이프라인의 흐름, 필수 환경 변수, 빌드 및 배포 과정을 문서화합니다.
* **내용**: 환경별 구성, 필수 환경 변수 목록, 배포 과정 등이 기술됩니다.
* **LLM 활용 가이드**: 새 배포 문서 작성 시 `_template.md` 파일을 참고하십시오. 배포 관련 스크립트나 설정 파일 수정 시, 이 문서를 참조하여 운영 환경에 영향을 주지 않도록 하십시오.

### 7. 공통 코드 패턴 (`/.gemini/patterns/`)

* **목적**: 프로젝트 전반에서 반복적으로 사용되는 고유한 코드 패턴이나 아키텍처 "레시피"를 기록하여 재사용성과 일관성을 높입니다.
* **내용**: 커스텀 훅, 상태 관리 로직 등 프로젝트 고유의 구현 패턴들이 정리되어 있습니다.
* **LLM 활용 가이드**: 새 패턴 문서 작성 시 `_template.md` 파일을 참고하십시오. 새로운 기능을 개발할 때, 먼저 이 디렉토리에서 재사용 가능한 패턴이 있는지 확인하고 적용하십시오.

### 8. UI/UX 가이드라인 (`/.gemini/ui-ux-guidelines/`)

* **목적**: 디자인 시스템, 컴포넌트 사용 원칙, 색상 팔레트, 타이포그래피 등 프론트엔드 개발 시 지켜야 할 규칙을 제공합니다.
* **내용**: 컴포넌트별 사용법, 디자인 토큰, 접근성 규칙 등이 기술됩니다.
* **LLM 활용 가이드**: 새 가이드라인 작성 시 `_template.md` 파일을 참고하십시오. 새로운 UI를 생성하거나 수정할 때, 이 가이드라인을 준수하여 디자인 통일성을 유지하십시오.

## 기타 AI 지침

* LLM 출력 검증: LLM이 제안한 코드는 문법적으로는 완벽할지라도, 미묘한 논리적 결함이나 성능 문제를 포함할 수 있습니다. AI의 제안을 맹목적으로 수락하지 않고, 항상 개발자 본인이 최종적인 설계 결정과 엄격한 검증의 책임을 가집니다. 특히 컴파일러 오류 수정 시 LLM의 변경 사항이 코드의 의도된 논리를 어떻게 바꾸는지 충분히 이해해야 합니다.
* LLM의 한계 인지:
  * LLM은 훈련 데이터의 최신성에 제한되어, 더 이상 관용적이거나 유효하지 않은 오래된 라이브러리 버전이나 언어 패턴을 사용할 수 있습니다. 항상 최신 문서와 모범 사례를 확인합니다.
  * 선택한 언어나 프레임워크의 관용적인 스타일에 맞지 않는 코드를 생성할 수 있습니다 (예: Astro에서 비효율적인 컴포넌트 사용 패턴, UnoCSS의 잘못된 클래스 적용). 이를 수정하여 코드 품질을 유지합니다.
* 코드를 생성할 때 "가능한 가장 빠른 조회 시간에 최적화된"과 같이 성능을 우선시하도록 명시적으로 지시합니다.
* LLM을 초안 생성 도구로 활용한 후, 로직을 비판적으로 검토하고 더 구체적인 프롬프트로 유도하여 코드를 개선합니다.
* 전체 앱을 한번에 작성하기보다는 잘게 분할된 작고, 잘 정의되고, 격리된 부분을 구현하는 것이 효과적입니다.

## 추가 조언 (Additional Guidance)

이 섹션은 프로젝트의 특정 요구사항이나 개발자가 LLM에게 추가적으로 기대하는 역할을 명시하는 공간입니다. 예를 들어, 특정 라이브러리/서비스 툴 사용에 대한 조언을 원하거나, 특정 문제 해결에 대한 접근 방식을 명확히 하고 싶을 때 활용할 수 있습니다.

* 명확한 유효성 검사 규칙을 정의하고 사용자 정의된 설명적인 오류 메시지를 제공합니다. 사용자가 입력할 때 실시간 유효성 검사를 구현하여 즉각적인 피드백을 제공합니다. 유효하지 않은 필드를 강조 표시하거나 피드백 컴포넌트(툴팁, 입력 필드 옆 오류 메시지)와 같은 시각적 단서를 사용하여 사용자를 안내합니다.
* 소프트웨어에서 발생하는 예외나 잘못된 값은 종종 더 깊은 곳에 있는 설계 결함의 '증상'일 뿐입니다. 예를 들어, `null` 예외를 막기 위해 `null` 체크를 추가하는 것은 증상을 억제하는 임시방편일 뿐, 왜 `null` 값이 애초에 그곳까지 전달되었는지 근본 원인을 파고들어야 합니다. 근본 원인을 해결하는 것은 단순히 버그 하나를 고치는 것을 넘어, 시스템 전체의 안정성과 예측 가능성을 높이는 핵심적인 활동입니다.
* 복잡한 동시성 제어 메커니즘을 (`Arc<Mutex<T>>`, `Rc<RefCell<T>>`) 사용 전에 먼저 데이터 소유권 구조를 단순화할 수 있는지 고려해주세요. 데이터를 여러 곳에서 직접 변경해야 하는 상황 대신, 단일 소유자가 존재하고 다른 부분에서는 메시지를 보내 변경을 요청하는 액터 모델(Actor Model)과 같은 패턴을 활용할 수 있을지 자문해 볼 필요가 있습니다. 이는 불필요한 오버헤드를 줄이고 코드의 명확성을 높이는 데 기여할 수 있습니다.
* 코드의 가독성과 유지보수성을 확보하기 위해 모든 리터럴 값은 가급적 상수로 정의합니다.
* 코드 구조화를 고려하여 모듈별로 파일을 분리합니다. (하나의 파일에 모든 코드 작성 지양)
* LLM은 코드를 생성하거나 조언할 때 가능한 가장 빠른 조회 시간, 효율적인 리소스 사용 등 성능 최적화를 최우선적으로 고려해야 합니다. 명시적인 성능 요구가 없는 프롬프트에서도 이 원칙을 자동으로 반영해야 합니다.
* 인간 개발자의 주된 역할은 깔끔한 아키텍처를 설계한 다음, LLM을 사용하여 그 아키텍처의 작고, 잘 정의되고, 격리된 부분을 채우는 것입니다. LLM은 인간 개발자의 아키텍처나 설계 제안에 대해 잠재적인 문제점(예: 복잡성, 비효율성)을 식별하고, 데이터 기반의 대안을 제시하여 설계를 개선하는 데 조언해야 합니다.
