# 프로젝트 가이드라인

이 문서는 LLM이 프로젝트의 맥락을 정확히 이해하고, 더 효율적이며 프로젝트에 특화된 도움을 제공하도록 돕기 위해 작성되었습니다.

## 프로젝트 개요 및 목표

* 프로젝트 이름: ZeroDi 개인 웹사이트
* 목표: 인디 개발자 'ZeroDi'의 개발 여정, 철학, 완성된 프로젝트를 효과적으로 공유하고, 비슷한 관심사를 가진 이들에게 영감을 주며, 잠재적 동료 및 팬들과 연결되는 것을 목표로 합니다. 비즈니스 의뢰 목적보다는 개인적인 브랜딩과 소통에 집중합니다.
* 주요 기능 (MVP): 이 프로젝트가 제공하는 핵심 기능들을 나열합니다. 각 기능에 해당하는 사용자 스토리 ID를 함께 명시하면 LLM이 특정 기능 개발 시 맥락을 이해하는 데 도움이 됩니다.
  * [US-001] "About Me" 섹션: 개발자 ZeroDi의 진솔한 개발 여정 스토리, 철학, 가치관을 담은 자기소개 페이지를 제공합니다.
  * [US-002] "Projects" 쇼케이스: ZeroDi가 만든 프로젝트들을 고품질 스크린샷, 데모 영상(링크), 기술 스택 아이콘, 간결한 설명과 함께 시각적으로 전시합니다.
  * [US-003] "Blog" (Indie Dev Log): ZeroDi의 개발 과정의 시행착오, 실험, 개인적인 생각, 영감 등을 자유롭게 기록하는 블로그 기능을 제공합니다.
  * [US-004] "Contact & Connect" 페이지: 이메일, 선호하는 SNS 링크, Ko-fi 후원 링크를 명확하고 친근하게 제시하여 방문자와의 소통을 유도합니다.
  * [US-005] 글로벌 내비게이션 바: Home, About, Projects, Blog, Contact 등 핵심 페이지로의 쉬운 이동을 위한 왼쪽 고정 내비게이션 바를 제공합니다.
  * [US-006] 반응형 디자인: 어떤 기기(모바일, 태블릿, 데스크톱)에서 접속해도 웹사이트가 최적화된 형태로 보기 좋게 표시됩니다.
  * [US-007] 최소한의 SEO 설정: 검색 엔진에서 기본적인 노출을 확보하기 위한 메타 태그, 제목 등 기본 SEO 요소를 설정합니다.
* 프로젝트 깃헙 레포지토리: `https://github.com/0disoft/0disoft.github.io`

## 기술 스택 및 환경

* 프론트엔드: Astro
  * 스타일링: UnoCSS
  * UI/UX 특징 (선택 사항): 깔끔하지만 따뜻한 '핸드메이드' 감성 디자인, 미니멀 & 모던 스타일 지향.
* 백엔드: 필요 없음
* 런타임: Bun
* 데이터베이스/BaaS: 필요 없음 (Astro Content Collections 활용)
* 배포 환경:
  * 프론트엔드 배포: GitHub Pages
  * 백엔드 배포: 해당 없음
* 의존성 관리: Bun을 패키지 매니저로 사용하며, 정기적인 의존성 업데이트 및 취약점 검토를 수행합니다.
* 지역화 (l10n, 선택 사항):
  * 다국어 페이지 지원 여부: 지원함 (MVP 이후 고려)
  * 기본 언어: 영어 (접속 국가 언어로 자동 선택 지원은 MVP 이후 고려)
  * 번역 파일 관리 방식: 수동 준비 (LLM을 이용한 직접 번역 포함)
* 개발 환경:
  * OS: **Windows 11**
  * IDE: **VS Code**
  * 터미널: **Git Bash**
  * 권장 확장 프로그램: VS Code with Astro, UnoCSS, Prettier, ESLint

## 코딩 규칙 및 스타일

* 코드 포맷팅: Prettier를 따르며, 코드 리뷰 전에 자동으로 포맷팅을 적용합니다.
* 변수/함수명: 명확하고 의미를 쉽게 유추할 수 있는 이름을 사용합니다. (예: `postList` 대신 `blogPosts`, `getPost` 대신 `fetchBlogPostBySlug`)
* 주석: 코드의 '어떻게(How)'가 아닌 '왜(Why)'를 설명하는 주석을 작성합니다. 복잡한 비즈니스 로직, 설계 결정, 기술적 절충안 등을 설명할 때만 사용합니다. 코드만 봐도 알 수 있는 명백한 사실은 굳이 주석으로 달아서 노이즈를 만들 필요 없습니다.
* 테스트: 핵심 기능(예: 데이터 파싱 로직, 유틸리티 함수)에 대해 단위 테스트를 작성할 수 있다면 고려합니다. (정적 사이트이므로 테스트 범위는 제한적일 수 있음)
* 코드 라인 길이: 한 줄의 최대 길이는 80자 (띄어쓰기 포함)를 지킵니다.
* 함수 길이: 함수의 최대 길이는 50라인 (주석 및 줄바꿈 포함)을 지킵니다. (과도한 함수 길이는 지양)
* 들여쓰기: 2칸 공백을 사용합니다.
* 커밋 메시지: Gitmoji 형식(`:emoji: type(scope): subject`)을 사용한 `영어` 코멘트를 작성합니다. (예: `:sparkles: feat: add about me section content`, `:bug: fix: blog post image loading issue`)

## 설계 원칙 및 제약 사항

* 모듈성: 코드를 작고 응집도 높은 컴포넌트와 모듈로 분리하여 재사용성과 유지보수성을 높입니다. (`+layout.svelte` 활용 등)
* 가독성: 다른 개발자가 코드를 쉽게 이해할 수 있도록 작성합니다.
* 성능: Astro와 Bun을 활용하여 페이지 로딩 속도를 최적화하고, 불필요한 JavaScript 번들링을 최소화합니다.
* 보안: 개인 사이트이므로 대규모 보안 위협은 낮으나, 기본적인 웹 보안(XSS 방지 등)을 준수하고 외부 라이브러리 사용 시 취약점 여부를 확인합니다.
* 데이터 정확성: 블로그 게시물, 프로젝트 설명 등 모든 콘텐츠는 사실에 기반하여 정확하게 작성합니다.
* 에러 처리: 정적 사이트이므로 런타임 에러 발생 시 사용자 경험을 해치지 않도록 방어적인 코드를 작성합니다. (예: 존재하지 않는 페이지 접근 시 404 페이지로 리디렉션)
* 접근성 (A11y): 웹 애플리케이션 개발 시 웹 접근성 표준을 준수하여 모든 사용자가 쉽게 접근하고 이용할 수 있도록 처음부터 강력한 접근성을 보장합니다.
* Single Source of Truth: 서비스 이름, 주요 링크, 상수 값 등은 코드 곳곳에 하드코딩하지 않고 별도의 상수 파일이나 설정 모듈에 모아서 관리합니다.

## 기타 AI 지침

* LLM 출력 검증: LLM이 제안한 코드는 문법적으로는 완벽할지라도, 미묘한 논리적 결함이나 성능 문제를 포함할 수 있습니다. AI의 제안을 맹목적으로 수락하지 않고, 항상 개발자 본인이 최종적인 설계 결정과 엄격한 검증의 책임을 가집니다. 특히 컴파일러 오류 수정 시 LLM의 변경 사항이 코드의 의도된 논리를 어떻게 바꾸는지 충분히 이해해야 합니다.
* LLM의 한계 인지:
  * LLM은 훈련 데이터의 최신성에 제한되어, 더 이상 관용적이거나 유효하지 않은 오래된 라이브러리 버전이나 언어 패턴을 사용할 수 있습니다. 항상 최신 문서와 모범 사례를 확인합니다.
  * 선택한 언어나 프레임워크의 관용적인 스타일에 맞지 않는 코드를 생성할 수 있습니다 (예: Astro에서 비효율적인 컴포넌트 사용 패턴, UnoCSS의 잘못된 클래스 적용). 이를 수정하여 코드 품질을 유지합니다.
* 코드를 생성할 때 "가능한 가장 빠른 조회 시간에 최적화된"과 같이 성능을 우선시하도록 명시적으로 지시합니다.
* LLM을 초안 생성 도구로 활용한 후, 로직을 비판적으로 검토하고 더 구체적인 프롬프트로 유도하여 코드를 개선합니다.
* 전체 앱을 한번에 작성하기보다는 잘게 분할된 작고, 잘 정의되고, 격리된 부분을 구현하는 것이 효과적입니다.

## 추가 조언 (Additional Guidance)

이 섹션은 프로젝트의 특정 요구사항이나 개발자가 LLM에게 추가적으로 기대하는 역할을 명시하는 공간입니다. 예를 들어, 특정 라이브러리/서비스 툴 사용에 대한 조언을 원하거나, 특정 문제 해결에 대한 접근 방식을 명확히 하고 싶을 때 활용할 수 있습니다.

* 명확한 유효성 검사 규칙을 정의하고 사용자 정의된 설명적인 오류 메시지를 제공합니다. 사용자가 입력할 때 실시간 유효성 검사를 구현하여 즉각적인 피드백을 제공합니다. 유효하지 않은 필드를 강조 표시하거나 피드백 컴포넌트(툴팁, 입력 필드 옆 오류 메시지)와 같은 시각적 단서를 사용하여 사용자를 안내합니다.
* 소프트웨어에서 발생하는 예외나 잘못된 값은 종종 더 깊은 곳에 있는 설계 결함의 '증상'일 뿐입니다. 예를 들어, `null` 예외를 막기 위해 `null` 체크를 추가하는 것은 증상을 억제하는 임시방편일 뿐, 왜 `null` 값이 애초에 그곳까지 전달되었는지 근본 원인을 파고들어야 합니다. 근본 원인을 해결하는 것은 단순히 버그 하나를 고치는 것을 넘어, 시스템 전체의 안정성과 예측 가능성을 높이는 핵심적인 활동입니다.
* 복잡한 동시성 제어 메커니즘을 (`Arc<Mutex<T>>`, `Rc<RefCell<T>>`) 사용 전에 먼저 데이터 소유권 구조를 단순화할 수 있는지 고려해주세요. 데이터를 여러 곳에서 직접 변경해야 하는 상황 대신, 단일 소유자가 존재하고 다른 부분에서는 메시지를 보내 변경을 요청하는 액터 모델(Actor Model)과 같은 패턴을 활용할 수 있을지 자문해 볼 필요가 있습니다. 이는 불필요한 오버헤드를 줄이고 코드의 명확성을 높이는 데 기여할 수 있습니다.
* 코드의 가독성과 유지보수성을 확보하기 위해 모든 리터럴 값은 가급적 상수로 정의합니다.
* 코드 구조화를 고려하여 모듈별로 파일을 분리합니다. (하나의 파일에 모든 코드 작성 지양)
* LLM은 코드를 생성하거나 조언할 때 가능한 가장 빠른 조회 시간, 효율적인 리소스 사용 등 성능 최적화를 최우선적으로 고려해야 합니다. 명시적인 성능 요구가 없는 프롬프트에서도 이 원칙을 자동으로 반영해야 합니다.
* 인간 개발자의 주된 역할은 깔끔한 아키텍처를 설계한 다음, LLM을 사용하여 그 아키텍처의 작고, 잘 정의되고, 격리된 부분을 채우는 것입니다. LLM은 인간 개발자의 아키텍처나 설계 제안에 대해 잠재적인 문제점(예: 복잡성, 비효율성)을 식별하고, 데이터 기반의 대안을 제시하여 설계를 개선하는 데 조언해야 합니다.
