# 블로그 포스트 중복 현상 원인 및 해결 방안

## 1. 원인 분석

현재 블로그 페이지에서 새로고침 시 포스트가 중복으로 나타나는 현상은 Astro의 서버 사이드 렌더링(SSR)과 클라이언트 사이드 무한 스크롤 스크립트의 실행 시점 차이 때문에 발생합니다.

1.  **서버 렌더링:** 사용자가 `/blog` 페이지에 처음 접속하면, Astro 서버는 `src/pages/blog/index.astro`를 통해 **초기 포스트 목록을 미리 렌더링**하여 완전한 HTML 페이지를 브라우저에 보냅니다.
2.  **클라이언트 스크립트 실행:** 브라우저는 서버로부터 받은 HTML을 화면에 표시한 직후, 페이지에 포함된 `src/scripts/blog-infinite-scroll.ts` 스크립트를 실행합니다.
3.  **중복 데이터 요청:** 현재 무한 스크롤 스크립트는 페이지가 로드되자마자 **첫 번째 페이지(page=1)의 데이터를 API에 다시 요청**하도록 되어 있을 가능성이 높습니다.
4.  **데이터 추가:** 스크립트는 API로부터 받은 첫 페이지 데이터를 이미 서버에서 그려준 포스트 목록 **아래에 그대로 추가**합니다.

결과적으로 서버에서 렌더링한 포스트 목록과 클라이언트에서 다시 요청한 포스트 목록이 합쳐져 중복으로 표시되는 것입니다.

## 2. 해결 방안

이 문제를 해결하기 위해서는 클라이언트의 무한 스크롤 스크립트가 **첫 페이지 데이터를 중복으로 불러오지 않도록** 수정해야 합니다. 스크립트는 사용자가 스크롤을 내려 페이지 하단에 도달했을 때, **두 번째 페이지(`page=2`)부터** 데이터를 요청하도록 로직을 변경해야 합니다.

## 3. 수정 제안 코드: `src/scripts/blog-infinite-scroll.ts`

아래는 위 해결 방안을 적용한 전체 코드 예시입니다. 이 코드로 기존 `src/scripts/blog-infinite-scroll.ts` 파일의 내용을 교체하면 문제를 해결할 수 있습니다.

```typescript
// src/scripts/blog-infinite-scroll.ts

document.addEventListener('DOMContentLoaded', () => {
  const postContainer = document.getElementById('post-container');
  const sentinel = document.getElementById('sentinel');

  if (!postContainer || !sentinel) {
    return;
  }

  // 페이지 번호를 2부터 시작하도록 초기화합니다.
  // 첫 페이지의 데이터는 이미 서버에서 렌더링했기 때문입니다.
  let currentPage = 2;
  let isLoading = false;
  let allPostsLoaded = false;

  async function loadMorePosts() {
    if (isLoading || allPostsLoaded) return;

    isLoading = true;
    sentinel.textContent = '로딩 중...';

    try {
      const response = await fetch(`/api/posts.json?page=${currentPage}`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const newPosts = await response.json();

      if (newPosts.length === 0) {
        allPostsLoaded = true;
        observer.unobserve(sentinel);
        sentinel.textContent = '모든 포스트를 불러왔습니다.';
        return;
      }

      newPosts.forEach((post: any) => {
        // BlogPostPreview.astro 컴포넌트의 구조와 스타일에 맞춰 HTML을 생성합니다.
        // 이 부분은 실제 컴포넌트의 HTML 구조와 클래스에 맞게 정확히 조정해야 합니다.
        const postLink = document.createElement('a');
        postLink.href = `/blog/${post.slug}`;
        postLink.className = "block p-6 rounded-lg transition-colors duration-300 hover:bg-gray-100 dark:hover:bg-gray-800";
        postLink.innerHTML = `
          <h2 class="text-2xl font-bold mb-2">${post.data.title}</h2>
          <p class="text-gray-600 dark:text-gray-400 mb-4">${post.data.description}</p>
          <time datetime="${post.data.pubDate.substring(0, 10)}" class="text-sm text-gray-500">
            ${new Date(post.data.pubDate).toLocaleDateString('ko-KR')}
          </time>
        `;
        postContainer.appendChild(postLink);
      });

      currentPage++;
    } catch (error) {
      console.error('Failed to load more posts:', error);
      sentinel.textContent = '포스트를 불러오는 데 실패했습니다.';
    } finally {
      isLoading = false;
    }
  }

  const observer = new IntersectionObserver(
    (entries) => {
      if (entries[0].isIntersecting && !isLoading) {
        loadMorePosts();
      }
    },
    { threshold: 1.0 }
  );

  observer.observe(sentinel);
});
```
